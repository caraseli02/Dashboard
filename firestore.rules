service cloud.firestore {
  match /databases/{database}/documents {
  	function isAdmin() {
      	return get(/databases/$(database)/documents/attendanceUsers/$(request.auth.uid)).data.isAdmin == true;
      }
    // helper functions
    function isDocOwner(){
      return request.auth.uid == resource.data.author;  	
    }
    
		function isStaff(){
      return request.auth.token.email.matches('.*apimosa[.]es$')
    }
     match /attendance/{document} {
      allow read: if (isDocOwner() && isSignedIn()) || isAdmin() || isStaff();
      allow create: if isSignedIn() || isAdmin() || isStaff();
      allow update: if (isDocOwner() && isSignedIn()) || isAdmin() || isStaff();
      allow delete: if isAdmin() || isStaff();
    }

    match /attendanceUsers/{document} {
      allow write: if isSignedIn();
      allow read, update: if isDocOwner() || isAdmin() || isStaff();
    }
  }

  // helper functions
  function isDocOwner(){
  // assuming document has a field author which is uid
  // Only the authenticated user who authored the document can read or write
  return request.auth.uid == resource.data.author;
  // This above read query will fail
  // The query fails even if the current user actually is the author of every story document.
  // The reason for this behavior is that when Cloud Firestore applies your security rules,
  // it evaluates the query against its potential result set,
  // not against the actual properties of documents in your database.
  // If a query could potentially include documents that violate your security rules,
  // the query will fail.
  // on your client app, make sure to include following
  // .where("author", "==", this.afAuth.auth.currentUser.uid)
  
  	
  }
  function isSignedIn() {
  // check if user is signed in
  return request.auth.uid != null;
  }
  function isAdmin() {
  return get(/databases/$(database)/documents/attendanceUsers/$(request.auth.uid)).data.isAdmin == true;
  }
}